use crate::instruction::{decode_op, Word};

#[macro_use]
extern crate uint;

pub mod instruction;

fn main() {
    println!("Hello, world!");
}

pub struct Context {
    codes: Vec<u8>,
    pc: usize,
    stack: Vec<Word>,
    remaining_gas: u128,
    refund_gas: u128,
    used_gas: u128,
}

impl Context {
    pub fn dump_stack(&self) {
        println!("stack: {:?}", self.stack)
    }
}

pub fn execute(opecodes: Vec<u8>) -> Context {
    let max_pc = opecodes.len();
    println!("{:?}", opecodes);
    let mut ctx = Context {
        codes: opecodes,
        pc: 0,
        stack: Vec::new(),
        remaining_gas: 0,
        refund_gas: 0,
        used_gas: 0,
    };

    while ctx.pc < max_pc {
        ctx = decode_op(ctx.codes[ctx.pc]).instruct(ctx);
        ctx.dump_stack();
    }
    ctx
}

#[test]
fn test_execute() {
    execute(vec![0x60, 0x01,
                 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03]);
    construct_uint! {
	    pub struct U256(4);
    }
    let bytes: &[u8; 32] = &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
    let p = U256::from_big_endian(
        bytes
    );
    let buf: &mut [u8] = &mut [0; 32];
    p.to_big_endian(buf);
    println!("u={:?}", (p.overflowing_add(U256::from(2_u64))));
}

#[test]
fn test_overflow_add() {
    use instruction::U256;
    let mut ctx = execute(vec![0x60, 0x01,
                               0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
}

#[test]
fn test_overflow_sub() {
    use instruction::U256;
    let mut ctx = execute(vec![0x60, 0x0a,
                               0x60, 0x01, 0x03]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from([
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, ]));
}

#[test]
fn test_overflow_mul() {
    use instruction::U256;
    let mut ctx = execute(vec![
        0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x60, 0x02, 0x02]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
}

#[test]
fn test_0_div() {
    use instruction::U256;
    let mut ctx = execute(vec![
        0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x60, 0x00, 0x04]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
    let mut ctx = execute(vec![
        0x60, 0x00,
        0x60, 0x04,
        0x04]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
}

#[test]
fn test_sdiv() {
    use instruction::U256;

    // -2 / -2
    let mut ctx = execute(vec![
        0x7f,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
        0x7f,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
        0x05]);
    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

    // -2 / 2
    let mut ctx = execute(vec![
        0x60, 0x02,
        0x7f,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
        0x05]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from([
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]));

    // 2 / -2
    let mut ctx = execute(vec![
        0x7f,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
        0x60, 0x02,
        0x05]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from([
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ]));

    // 2 / 2
    let mut ctx = execute(vec![
        0x60, 0x02,
        0x60, 0x02,
        0x05]);

    assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));
}