use crate::instruction::{decode_op, Word};

#[macro_use]
extern crate uint;

pub mod instruction;

fn main() {
    println!("Hello, world!");
}

pub struct Context {
    codes: Vec<u8>,
    pc: usize,
    stack: Vec<Word>,
    remaining_gas: u64,
    refund_gas: u64,
    used_gas: u64,
}

impl Context {
    pub fn dump_stack(&self) {
        println!("stack: {:?}", self.stack)
    }
}

pub fn execute(opecodes: Vec<u8>) -> Context {
    let max_pc = opecodes.len();
    println!("{:?}", opecodes);
    let mut ctx = Context {
        codes: opecodes,
        pc: 0,
        stack: Vec::new(),
        remaining_gas: 0,
        refund_gas: 0,
        used_gas: 0,
    };

    while ctx.pc < max_pc {
        ctx = decode_op(ctx.codes[ctx.pc]).instruct(ctx);
        ctx.dump_stack();
    }
    ctx
}

mod test {
    use crate::execute;
    use crate::instruction::U256;

    const U256_MAX_BYTES: [u8; 32] = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    ];

    #[test]
    fn test_execute() {
        execute(vec![0x60, 0x01,
                     0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03]);
        construct_uint! {
	    pub struct U256(4);
    }
        let bytes: &[u8; 32] = &[0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
        let p = U256::from_big_endian(
            bytes
        );
        let buf: &mut [u8] = &mut [0; 32];
        p.to_big_endian(buf);
        println!("u={:?}", (p.overflowing_add(U256::from(2_u64))));
    }

    #[test]
    fn test_overflow_add() {
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x01]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
    }

    #[test]
    fn test_overflow_sub() {
        let mut ctx = execute(vec![
            0x60, 0x0a,
            0x60, 0x01,
            0x03]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from([
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, ]));
    }

    #[test]
    fn test_overflow_mul() {
        let mut ctx = execute(vec![
            0x7f,
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x60, 0x02,
            0x02]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
    }

    #[test]
    fn test_0_div() {
        let mut ctx = execute(vec![
            0x7f,
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x60, 0x00,
            0x04]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x60, 0x04,
            0x04]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
    }

    #[test]
    fn test_sdiv() {
        // -2 / -2
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x05]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        // -2 / 2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x05]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(U256_MAX_BYTES));

        // 2 / -2
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x60, 0x02,
            0x05]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(U256_MAX_BYTES));

        // 2 / 2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x60, 0x02,
            0x05]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));
    }

    #[test]
    fn test_mod() {
        // 7 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x60, 0x07,
            0x06]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1_u32));

        // 8 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x60, 0x08,
            0x06]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(2_u32));

        // 8 mod 9
        let mut ctx = execute(vec![
            0x60, 0x09,
            0x60, 0x08,
            0x06]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(8_u32));

        // 7 mod 0
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x60, 0x07,
            0x06]);

        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
    }

    #[test]
    fn test_smod() {
        // 7 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x60, 0x07,
            0x07]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1_u32));

        // 7 mod 0
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x60, 0x07,
            0x07]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));

        // -7 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9,
            0x07]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(U256_MAX_BYTES));
    }

    #[test]
    fn test_addmod() {
        // 2 + 5 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x60, 0x05,
            0x60, 0x02,
            0x08]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1_u32));

        // 2 + 5 mod 0
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x60, 0x05,
            0x60, 0x02,
            0x08]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));
    }

    #[test]
    fn test_mulmod() {
        // 2 * 4 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x60, 0x04,
            0x60, 0x02,
            0x09]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(2_u32));

        // 2 * 4 mod 0
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x60, 0x04,
            0x60, 0x02,
            0x09]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));

        //  overflowing 7 mod 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x7f,
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
            0x60, 0x02,
            0x09]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(2_u32));
    }

    #[test]
    fn test_exp() {
        // 2 ^ 3
        let mut ctx = execute(vec![
            0x60, 0x03,
            0x60, 0x02,
            0x0a]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(8_u32));
        assert_eq!(ctx.used_gas, 66);

        // 2 ^ 0
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x60, 0x02,
            0x0a]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1_u32));
        // 0^2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x60, 0x00,
            0x0a]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0_u32));

        // 2^255
        let mut ctx = execute(vec![
            0x60, 0xff,
            0x60, 0x02,
            0x0a]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from([
            0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]));

        // 3^115792089237316195423570985008687907853269984665640564039457584007913129639935
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x60, 0x03,
            0x0a]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()),
                   U256::from_dec_str("77194726158210796949047323339125271902179989777093709359638389338608753093291").unwrap());
        assert_eq!(ctx.used_gas, 1616);
    }

    #[test]
    fn test_signextend() {
        // -1_i16 signext 2
        let mut ctx = execute(vec![
            0x61, 0xff, 0xff,
            0x60, 0x01,
            0x0b]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(U256_MAX_BYTES));
        println!("bool to u256={:?}", U256::from((3 < 2) as u8));
    }

    #[test]
    fn test_lt() {
        // 1 < 2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x60, 0x01,
            0x10]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        // 2 < 2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x60, 0x02,
            0x10]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));

        // 2 < 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x60, 0x02,
            0x10]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));
    }

    #[test]
    fn test_gt() {
        // 1 > 2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x60, 0x01,
            0x11]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));

        // 2 > 2
        let mut ctx = execute(vec![
            0x60, 0x02,
            0x60, 0x02,
            0x11]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));

        // 2 > 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x60, 0x02,
            0x11]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));
    }

    #[test]
    fn test_slt() {
        // -2 < 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x12]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        // 2 < 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x60, 0x02,
            0x12]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));
        // -2 < -1
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x12]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        // -2 < -2
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x12]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));
    }

    #[test]
    fn test_sgt() {
        // -2 > 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x13]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));

        // 2 > 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x60, 0x02,
            0x13]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        // -2 > -1
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x13]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));

        // -2 > -2
        let mut ctx = execute(vec![
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x7f,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
            0x13]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));
    }

    #[test]
    fn test_eq() {
        // 1 == 1
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x60, 0x01,
            0x14]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        // 1 == 2
        let mut ctx = execute(vec![
            0x60, 0x01,
            0x60, 0x02,
            0x14]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));
    }

    #[test]
    fn test_iszero() {
        let mut ctx = execute(vec![
            0x60, 0x00,
            0x15]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));

        let mut ctx = execute(vec![
            0x60, 0x01,
            0x15]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(0));
    }

    #[test]
    fn test_and() {
        let mut ctx = execute(vec![
            0x61, 0xff, 0xff,
            0x60, 0x01,
            0x16]);
        assert_eq!(U256::from(ctx.stack.pop().unwrap()), U256::from(1));
    }
}